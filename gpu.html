<html>
	<head>
		<title>Globe of Life</title>
		<meta charset="utf-8">
		<style>
			body { margin: 0; }
			canvas { width: 100%; height: 100% }
		</style>
	</head>
	<body>
		<script src="three.min.js"></script>
		<script src="TrackballControls.js"></script>

		<!-- consts -->
		<script>
			var WIDTH = 256;
			var OMINOES = 1000;
		</script>

		<!-- pass through vertex shader -->
		<script id="ptVertexShader" type="x-shader/x-vertex">
			void main()	{
				gl_Position = vec4( position, 1.0 );
			}
		</script>

		<!-- pass through fragment shader -->
		<script id="ptFragmentShader" type="x-shader/x-fragment">
			uniform vec2 resolution;
			uniform sampler2D texture;

			void main()	{
				vec2 uv = vec2((gl_FragCoord.x) / resolution.x,gl_FragCoord.y / resolution.y);
				vec4 color = texture2D( texture, uv );
				gl_FragColor = vec4( color );
			}
		</script>

		<!-- pass through fragment shader with rotation -->
		<script id="ptrFragmentShader" type="x-shader/x-fragment">
			uniform vec2 resolution;
			uniform sampler2D texture;

			void main()	{
				vec2 uv = vec2((gl_FragCoord.x) / resolution.x,gl_FragCoord.y / resolution.y);
				vec4 color = texture2D( texture, uv );
				gl_FragColor = vec4( color.argb );
			}
		</script>

		<!-- sand shader -->
		<script id="sandShader" type="x-shader/x-fragment">

			//width of textures
			uniform vec2 resolution;

			//previous values
			//x - x-speed
			//y - y-speed
			//z - mass/type
			//w - amount
			uniform sampler2D old;

			//previous environment
			uniform sampler2D world;

			//user position, request
			uniform vec3 interact;

			const float PI = 3.141592653589793;

			//code for this material type
			const float sandMass = 1.0;

			void main()	{

				float amount = 0.0;
				float type = sandMass;

				//calculate 3x3 nearby positions and values
				float l = (gl_FragCoord.x - 1.0) / resolution.x;
				float m = (gl_FragCoord.x) / resolution.x;
				float r = (gl_FragCoord.x + 1.0) / resolution.x;
				float b = (gl_FragCoord.y - 1.0) / resolution.y;
				float c = (gl_FragCoord.y) / resolution.y;
				float t = (gl_FragCoord.y + 1.0) / resolution.y;
				vec4 lt = texture2D( old, vec2(l, t));
				vec4 mt = texture2D( old, vec2(m, t));
				vec4 rt = texture2D( old, vec2(r, t));
				vec4 lc = texture2D( old, vec2(l, c));
				vec4 mc = texture2D( old, vec2(m, c));
				vec4 rc = texture2D( old, vec2(r, c));
				vec4 lb = texture2D( old, vec2(l, b));
				vec4 mb = texture2D( old, vec2(m, b));
				vec4 rb = texture2D( old, vec2(r, b));
				vec4 wlt = texture2D( world, vec2(l, t));
				vec4 wmt = texture2D( world, vec2(m, t));
				vec4 wrt = texture2D( world, vec2(r, t));
				vec4 wlc = texture2D( world, vec2(l, c));
				vec4 wmc = texture2D( world, vec2(m, c));
				vec4 wrc = texture2D( world, vec2(r, c));
				vec4 wlb = texture2D( world, vec2(l, b));
				vec4 wmb = texture2D( world, vec2(m, b));
				vec4 wrb = texture2D( world, vec2(r, b));

				float income;
				float loss;

				amount = mc.a;

				income = clamp((lt.a - 1.0)*0.125,0.0,1.0);
				if(lt.x > 0.0 && lt.y < 0.0){
					income += clamp(clamp(1.0 - wmc.a, 0.0, 1.0 - income ), 0.0, lt.a);
				}
				amount += income;
				income = clamp((mt.a - 1.0)*0.125,0.0,1.0);
				if(mt.x == 0.0 && mt.y < 0.0){
					income += clamp(clamp(1.0 - wmc.a, 0.0, 1.0 - income ), 0.0, mt.a);
				}
				amount += income;
				income = clamp((rt.a - 1.0)*0.125,0.0,1.0);
				if(rt.x < 0.0 && rt.y < 0.0){
					income += clamp(clamp(1.0 - wmc.a, 0.0, 1.0 - income ), 0.0, rt.a);
				}
				amount += income;
				income = clamp((lc.a - 1.0)*0.125,0.0,1.0);
				if(lc.x > 0.0 && lc.y == 0.0){
					income += clamp(clamp(1.0 - wmc.a, 0.0, 1.0 - income ), 0.0, lc.a);
				}
				amount += income;
				income = clamp((rc.a - 1.0)*0.125,0.0,1.0);
				if(rc.x < 0.0 && rc.y == 0.0){
					income += clamp(clamp(1.0 - wmc.a, 0.0, 1.0 - income ), 0.0, rc.a);
				}
				amount += income;
				income = clamp((lb.a - 1.0)*0.125,0.0,1.0);
				if(lb.x > 0.0 && lb.y > 0.0){
					income += clamp(clamp(1.0 - wmc.a, 0.0, 1.0 - income ), 0.0, lb.a);
				}
				amount += income;
				income = clamp((mb.a - 1.0)*0.125,0.0,1.0);
				if(mb.x == 0.0 && mb.y > 0.0){
					income += clamp(clamp(1.0 - wmc.a, 0.0, 1.0 - income ), 0.0, mb.a);
				}
				amount += income;
				income = clamp((rb.a - 1.0)*0.125,0.0,1.0);
				if(rb.x < 0.0 && rb.y > 0.0){
					income += clamp(clamp(1.0 - wmc.a, 0.0, 1.0 - income ), 0.0, rb.a);
				}
				amount += income;

				loss = clamp((mc.a - 1.0)*0.125,0.0,1.0);
				if(mc.x > 0.0){
					if(mc.y > 0.0) loss += clamp(clamp(1.0 - wrt.a, 0.0, 1.0 - loss), 0.0, mc.a);
					else if(mc.y < 0.0) loss += clamp(clamp(1.0 - wrb.a, 0.0, 1.0 - loss), 0.0, mc.a);
					else loss += clamp(clamp(1.0 - wrc.a, 0.0, 1.0 - loss), 0.0, mc.a);
				}else if(mc.x < 0.0){
					if(mc.y > 0.0) loss += clamp(clamp(1.0 - wlt.a, 0.0, 1.0 - loss), 0.0, mc.a);
					else if(mc.y < 0.0) loss += clamp(clamp(1.0 - wlb.a, 0.0, 1.0 - loss), 0.0, mc.a);
					else loss += clamp(clamp(1.0 - wlc.a, 0.0, 1.0 - loss), 0.0, mc.a);
				}else{
					if(mc.y > 0.0) loss += clamp(clamp(1.0 - wmt.a, 0.0, 1.0 - loss), 0.0, mc.a);
					else if(mc.y < 0.0) loss += clamp(clamp(1.0 - wmb.a, 0.0, 1.0 - loss), 0.0, mc.a);
				}
				amount -= loss + clamp((mc.a - 1.0)*0.125,0.0,1.0) * 7.0;

				//add a pixel at the mouse position
				if(
					interact.x < gl_FragCoord.x &&
					interact.y < gl_FragCoord.y &&
					interact.x + 1. > gl_FragCoord.x &&
					interact.y + 1. > gl_FragCoord.y
				){
					amount += interact.z;
				}

				gl_FragColor = vec4(0.0, -1.0, type, amount );
			}

		</script>

		<!-- environment shader -->
		<script id="envShader" type="x-shader/x-fragment">

			//width of textures
			uniform vec2 resolution;
			uniform sampler2D sand;

			void main()	{

				float bestMass = 0.;
				float bestAmt = 0.;
				float totAmt = 0.;

				vec4 sandVal = texture2D( sand, vec2(gl_FragCoord.x, gl_FragCoord.y) / resolution.xy);

				if(sandVal.a > bestAmt) {
					bestMass = sandVal.z;
					bestAmt = sandVal.a;
				}
				totAmt += sandVal.a;

				//make bounding box
				if(
					gl_FragCoord.x < 1. ||
					gl_FragCoord.x > resolution.x - 1. ||
					gl_FragCoord.y < 1. ||
					gl_FragCoord.y > resolution.y - 1.
				){
					bestMass = 100.;
					totAmt = 10.;
				}

				gl_FragColor = vec4(0.0, 0.0, bestMass, totAmt);
			}

		</script>

		<!-- output shader -->
		<script id="outShader" type="x-shader/x-fragment">

			//width of textures
			uniform vec2 resolution;
			uniform sampler2D env;

			void main()	{

				vec4 data = texture2D( env, vec2(gl_FragCoord.x, gl_FragCoord.y) / resolution.xy);
				float type = data.z;
				vec3 outColor = vec3(1.,0.,0.);


				if(type == 0.0) outColor = vec3(0., 0., 0.);
				if(type == 1.0) outColor = vec3(.7, .5, .3);
				if(type == 2.0) outColor = vec3(.3, .5, .7);
				if(type == 100.0) outColor = vec3(1., 1., 1.);

				//give a sence of how much is there
				outColor *= data.a;

				gl_FragColor = vec4(outColor, 1.0);
			}

		</script>

		<!-- util -->
		<script>
			function getRandomInt(min, max) {
    			return Math.floor(Math.random() * (max - min + 1)) + min;
			}
			function getRenderTarget() {
				var renderTarget = new THREE.WebGLRenderTarget(WIDTH, WIDTH, {
					//wrapS: THREE.RepeatWrapping,
					//wrapT: THREE.RepeatWrapping,
					minFilter: THREE.NearestFilter,
					magFilter: THREE.NearestFilter,
					format: THREE.RGBAFormat,
					type: THREE.FloatType,
					stencilBuffer: false,
				});

				return renderTarget;
			}
		</script>

		<!-- main -->
		<script>
			//var scene = new THREE.Scene();
			//var camera = new THREE.PerspectiveCamera( 75, window.innerWidth/window.innerHeight, 0.1, 1000 );

			var renderer = new THREE.WebGLRenderer();
			renderer.setSize( WIDTH, WIDTH);//window.innerWidth, window.innerHeight );
			document.body.appendChild( renderer.domElement );
			//camera.position.z = 8;

			//var bgGeo = new THREE.PlaneBufferGeometry(2000,2000);
			//var bgMat = new THREE.MeshBasicMaterial({color: 0x000044})
			//var bgMesh = new THREE.Mesh(bgGeo, bgMat);
			//scene.add(bgMesh);
			//bgMesh.position.z -= 10;
			// var sphereGeo = new THREE.SphereGeometry(6,50,50);
			// var redMat = new THREE.MeshBasicMaterial({color: 0xff0000})
			// var sphereMesh = new THREE.Mesh(sphereGeo, redMat);
			// scene.add(sphereMesh);




			var texCam = new THREE.Camera();
			texCam.position.z = 1;
			var sandTex0 = getRenderTarget();
			var sandTex1 = getRenderTarget();
			var envTex = getRenderTarget();

			var passThruShader = new THREE.ShaderMaterial( {
				uniforms:{ 
					resolution: { type: "v2", value: new THREE.Vector2( WIDTH, WIDTH ) },
					texture: { type: "t", value: null },
				},
				vertexShader: document.getElementById( 'ptVertexShader' ).textContent,
				fragmentShader: document.getElementById( 'ptFragmentShader' ).textContent
			} );
			var rotShader = new THREE.ShaderMaterial( {
				uniforms:{ 
					resolution: { type: "v2", value: new THREE.Vector2( WIDTH, WIDTH ) },
					texture: { type: "t", value: null },
				},
				vertexShader: document.getElementById( 'ptVertexShader' ).textContent,
				fragmentShader: document.getElementById( 'ptrFragmentShader' ).textContent
			} );
			var sandShader = new THREE.ShaderMaterial( {
				uniforms:{ 
					resolution: { type: "v2", value: new THREE.Vector2( WIDTH, WIDTH ) },
					old: { type: "t", value: null },
					world: { type: "t", value: envTex },
					interact: { type: "v3", value: new THREE.Vector3() },

				},
				vertexShader: document.getElementById( 'ptVertexShader' ).textContent,
				fragmentShader: document.getElementById( 'sandShader' ).textContent
			} );
			var envShader = new THREE.ShaderMaterial( {
				uniforms:{ 
					resolution: { type: "v2", value: new THREE.Vector2( WIDTH, WIDTH ) },
					sand: { type: "t", value: null },

				},
				vertexShader: document.getElementById( 'ptVertexShader' ).textContent,
				fragmentShader: document.getElementById( 'envShader' ).textContent
			} );
			var outShader = new THREE.ShaderMaterial( {
				uniforms:{ 
					resolution: { type: "v2", value: new THREE.Vector2( WIDTH, WIDTH ) },
					env: { type: "t", value: envTex },

				},
				vertexShader: document.getElementById( 'ptVertexShader' ).textContent,
				fragmentShader: document.getElementById( 'outShader' ).textContent
			} );
			var texScene = new THREE.Scene();
			var texMesh = new THREE.Mesh( new THREE.PlaneBufferGeometry( 2, 2 ), passThruShader );
			texScene.add(texMesh);

			// Takes a texture, and render out as another texture
			var renderTexture = function ( input, output ) {
				texMesh.material = passThruShader;
				passThruShader.uniforms.texture.value = input;
				renderer.render( texScene, texCam, output );
			}
			var renderTick = function(input, shader, output) {
				texMesh.material = shader;
				shader.uniforms.old.value = input;
				shader.uniforms.interact.value.set(mouseX,mouseY,mouseValue);
				renderer.render( texScene, texCam, output );
			}
			var renderEnv = function(use0) {
				texMesh.material = envShader;
				envShader.uniforms.sand.value = use0 ? sandTex0 : sandTex1;
				renderer.render( texScene, texCam, envTex );
			}
			var renderFinal = function() {
				texMesh.material = outShader;
				renderer.render( texScene, texCam );
			}
			var viewTex = function(input) {
				texMesh.material = rotShader;
				passThruShader.uniforms.texture.value = input;
				renderer.render( texScene, texCam );
			}
			var flipflop = false;
			var flip = function() {
				if (flipflop) {
					renderTick( sandTex1, sandShader, sandTex0 );
					renderEnv(flipflop);
				} else {
					renderTick( sandTex0, sandShader, sandTex1 );
					renderEnv(flipflop);
				}
				flipflop = !flipflop;
			}

			//initialize data
			var a = new Float32Array( WIDTH * WIDTH * 4 );

			var texture = new THREE.DataTexture( a, WIDTH, WIDTH, THREE.RGBAFormat, THREE.FloatType );
			texture.minFilter = THREE.NearestFilter;
			texture.magFilter = THREE.NearestFilter;
			texture.needsUpdate = true;
			texture.flipY = false;
			renderTexture(texture, sandTex0);




			//sphereMesh.material = new THREE.MeshBasicMaterial({map: tex1});


			//window.addEventListener( 'resize', onWindowResize, false );
			document.addEventListener("keydown", onKeyDown, false);
			document.addEventListener("keyup",   onKeyUp,   false);
			document.addEventListener( 'mousemove', onMouseM, false );
			document.addEventListener( 'mousedown', onMouseD, false );
			document.addEventListener( 'mouseup', onMouseU, false );
			
			//inital status
			mouseX = 0;
			mouseY = 0;
			mouseValue = 0.0;
			windowHalfX = window.innerWidth / 2;
			windowHalfY = window.innerHeight / 2;

			function onMouseM( event ) {
				mouseX = event.clientX;
				mouseY = WIDTH - event.clientY;
			}
			function onMouseD( event ) {
				mouseValue = 1.0;
			}
			function onMouseU( event ) {
				mouseValue = 0.0;
			}
			repeat = true;
			function onKeyDown(){
				repeat = !repeat;
			}
			function onKeyUp(){
				//repeat = true;
			}

			function onWindowResize() {

				windowHalfX = window.innerWidth / 2;
				windowHalfY = window.innerHeight / 2;

				//camera.aspect = window.innerWidth / window.innerHeight;
				//camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			var framecount = 0;
			var oldtime = new Date().getTime();

			var render = function () {
				requestAnimationFrame( render );
				if(repeat) {
					flip();
					//fast
					flip();flip();flip();
					//flip();flip();flip();flip();

					//viewTex(flipflop ? sandTex0 : sandTex1);
					//viewTex(envTex);
					renderFinal();

					//console frames per second
					framecount++;
					var newtime = new Date().getTime();
					if(newtime-oldtime>1000){
						oldtime = newtime;
						console.log(framecount);
						framecount = 0;
					}

				}
			};
			render();



		</script>
	</body>
</html>