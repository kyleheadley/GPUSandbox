<html>
	<head>
		<title>Dynamic Color</title>
		<meta charset="utf-8">
		<style>
			body { margin: 0; }
			canvas { width: 100%; height: 100% }
		</style>
	</head>
	<body>
		<script src="three.min.js"></script>

		<!-- consts -->
		<script>
			var WIDTH = 512;
		</script>

		<!-- pass through vertex shader -->
		<script id="ptVertexShader" type="x-shader/x-vertex">
			void main()	{
				gl_Position = vec4( position, 1.0 );
			}
		</script>

		<!-- pass through fragment shader -->
		<script id="ptFragmentShader" type="x-shader/x-fragment">
			uniform vec2 resolution;
			uniform sampler2D texture;

			void main()	{
				vec2 uv = gl_FragCoord.xy / resolution.xy;
				vec4 color = texture2D( texture, uv );
				gl_FragColor = vec4( color );
			}
		</script>

		<!-- pass through fragment shader with color rotation -->
		<script id="ptrFragmentShader" type="x-shader/x-fragment">
			uniform vec2 resolution;
			uniform sampler2D texture;

			void main()	{
				vec2 uv = gl_FragCoord.xy / resolution.xy;
				vec4 color = texture2D( texture, uv );
				gl_FragColor = vec4( color.argb );
			}
		</script>

		<!-- show amount -->
		<script id="saFragmentShader" type="x-shader/x-fragment">
			uniform vec2 resolution;
			uniform sampler2D texture;

			void main()	{
				vec2 uv = gl_FragCoord.xy / resolution.xy;
				vec4 color = texture2D( texture, uv );
				gl_FragColor = vec4( color.a );
			}
		</script>

		<!-- effect shader -->
		<script id="effectShader" type="x-shader/x-fragment">

			//width of textures
			uniform vec2 resolution;

			//previous values
			//r,g,b,a = red, green, blue, amount
			uniform sampler2D old;

			//user position, request
			uniform vec4 interact;
			//interaction color
			uniform vec3 icolor;

			void main()	{
				//calculate 3x3 nearby positions and values
				float l = (gl_FragCoord.x - 1.0) / resolution.x;
				float m = (gl_FragCoord.x) / resolution.x;
				float r = (gl_FragCoord.x + 1.0) / resolution.x;
				float b = (gl_FragCoord.y - 1.0) / resolution.y;
				float c = (gl_FragCoord.y) / resolution.y;
				float t = (gl_FragCoord.y + 1.0) / resolution.y;
				//vec4 lt = texture2D( old, vec2(l, t));
				vec4 mt = texture2D( old, vec2(m, t));
				//vec4 rt = texture2D( old, vec2(r, t));
				vec4 lc = texture2D( old, vec2(l, c));
				vec4 mc = texture2D( old, vec2(m, c));
				vec4 rc = texture2D( old, vec2(r, c));
				//vec4 lb = texture2D( old, vec2(l, b));
				vec4 mb = texture2D( old, vec2(m, b));
				//vec4 rb = texture2D( old, vec2(r, b));

				
				vec3 col = mc.rgb;

				float amount = clamp(mc.a, 0.0, 0.5);
				float income = (
					max((mt.a-0.5)*0.25,0.0) + 
					max((lc.a-0.5)*0.25,0.0) + 
					max((rc.a-0.5)*0.25,0.0) + 
					max((mb.a-0.5)*0.25,0.0)
					);
				amount += income;

				if(amount < mt.a) col = mt.rgb;
				if(amount < lc.a) col = lc.rgb;
				if(amount < rc.a) col = rc.rgb;
				if(amount < mb.a) col = mb.rgb;

				//add a pixel at the mouse position
				if(
					interact.x < gl_FragCoord.x &&
					interact.y < gl_FragCoord.y &&
					interact.x + 1. > gl_FragCoord.x &&
					interact.y + 1. > gl_FragCoord.y &&
					interact.a > 0.0
				){
					amount = amount + interact.a;
					col = icolor * interact.a;
				}

				gl_FragColor = vec4(col, amount);
			}

		</script>

		<!-- effect shader -->
		<script id="effect2Shader" type="x-shader/x-fragment">

			//width of textures
			uniform vec2 resolution;

			//previous values
			//r,g,b,a = red, green, blue, amount
			uniform sampler2D old;

			//user position, request
			uniform vec4 interact;
			//interaction color
			uniform vec3 icolor;

			float ct = cos(0.5);
			float st = sin(0.5);

			void main()	{
				//calculate 3x3 nearby positions and values
				float l = (gl_FragCoord.x - 1.0) / resolution.x;
				float m = (gl_FragCoord.x) / resolution.x;
				float r = (gl_FragCoord.x + 1.0) / resolution.x;
				float b = (gl_FragCoord.y - 1.0) / resolution.y;
				float c = (gl_FragCoord.y) / resolution.y;
				float t = (gl_FragCoord.y + 1.0) / resolution.y;
				l = (l-0.5);
				m = (m-0.5);
				r = (r-0.5);
				b = (b-0.5);
				c = (c-0.5);
				t = (t-0.5);
				vec2 mtp = vec2(m*ct-t*st, t*ct+m*st)+vec2(.5,.5);
				vec2 lcp = vec2(l*ct-c*st, c*ct+l*st)+vec2(.5,.5);
				vec2 mcp = vec2(m*ct-c*st, c*ct+m*st)+vec2(.5,.5);
				vec2 rcp = vec2(r*ct-c*st, c*ct+r*st)+vec2(.5,.5);
				vec2 mbp = vec2(m*ct-b*st, b*ct+m*st)+vec2(.5,.5);
				vec4 mt = texture2D( old, mtp);
				vec4 lc = texture2D( old, lcp);
				vec4 mc = texture2D( old, mcp);
				vec4 rc = texture2D( old, rcp);
				vec4 mb = texture2D( old, mbp);

				
				vec3 col = mc.rgb;

				float amount = clamp(mc.a, 0.0, 0.5);
				float income = (
					max((mt.a-0.5)*0.25,0.0) + 
					max((lc.a-0.5)*0.25,0.0) + 
					max((rc.a-0.5)*0.25,0.0) + 
					max((mb.a-0.5)*0.25,0.0)
					);
				amount += income;

				if(amount < mt.a) col = mt.rgb;
				if(amount < lc.a) col = lc.rgb;
				if(amount < rc.a) col = rc.rgb;
				if(amount < mb.a) col = mb.rgb;

				//add a pixel at the mouse position
				if(
					interact.x < gl_FragCoord.x &&
					interact.y < gl_FragCoord.y &&
					interact.x + 1. > gl_FragCoord.x &&
					interact.y + 1. > gl_FragCoord.y &&
					interact.a > 0.0
				){
					amount = amount + interact.a;
					col = icolor * interact.a;
				}

				gl_FragColor = vec4(col, amount);
			}

		</script>

		<!-- util -->
		<script>
			function getRandomInt(min, max) {
    			return Math.floor(Math.random() * (max - min + 1)) + min;
			}
			function getRenderTarget() {
				var renderTarget = new THREE.WebGLRenderTarget(WIDTH, WIDTH, {
					wrapS: THREE.RepeatWrapping,
					wrapT: THREE.RepeatWrapping,
					minFilter: THREE.NearestFilter,
					magFilter: THREE.NearestFilter,
					format: THREE.RGBAFormat,
					type: THREE.FloatType,
					stencilBuffer: false,
				});

				return renderTarget;
			}
		</script>

		<!-- main -->
		<script>
			var renderer = new THREE.WebGLRenderer();
			renderer.setSize( WIDTH, WIDTH);//window.innerWidth, window.innerHeight );
			document.body.appendChild( renderer.domElement );

			var texCam = new THREE.Camera();
			texCam.position.z = 1;
			var canvTex0 = getRenderTarget();
			var canvTex1 = getRenderTarget();

			var passThruShader = new THREE.ShaderMaterial( {
				uniforms:{ 
					resolution: { type: "v2", value: new THREE.Vector2( WIDTH, WIDTH ) },
					texture: { type: "t", value: null },
				},
				vertexShader: document.getElementById( 'ptVertexShader' ).textContent,
				fragmentShader: document.getElementById( 'ptFragmentShader' ).textContent
			} );
			var saShader = new THREE.ShaderMaterial( {
				uniforms:{ 
					resolution: { type: "v2", value: new THREE.Vector2( WIDTH, WIDTH ) },
					texture: { type: "t", value: null },
				},
				vertexShader: document.getElementById( 'ptVertexShader' ).textContent,
				fragmentShader: document.getElementById( 'saFragmentShader' ).textContent
			} );
			var rotShader = new THREE.ShaderMaterial( {
				uniforms:{ 
					resolution: { type: "v2", value: new THREE.Vector2( WIDTH, WIDTH ) },
					texture: { type: "t", value: null },
				},
				vertexShader: document.getElementById( 'ptVertexShader' ).textContent,
				fragmentShader: document.getElementById( 'ptrFragmentShader' ).textContent
			} );
			var effectShader = new THREE.ShaderMaterial( {
				uniforms:{ 
					resolution: { type: "v2", value: new THREE.Vector2( WIDTH, WIDTH ) },
					old: { type: "t", value: null },
					interact: { type: "v4", value: new THREE.Vector4() },
					icolor: { type:"v3", value: new THREE.Vector3() },

				},
				vertexShader: document.getElementById( 'ptVertexShader' ).textContent,
				fragmentShader: document.getElementById( 'effectShader' ).textContent
			} );
			var effect2Shader = new THREE.ShaderMaterial( {
				uniforms:{ 
					resolution: { type: "v2", value: new THREE.Vector2( WIDTH, WIDTH ) },
					old: { type: "t", value: null },
					interact: { type: "v4", value: new THREE.Vector4() },
					icolor: { type:"v3", value: new THREE.Vector3() },

				},
				vertexShader: document.getElementById( 'ptVertexShader' ).textContent,
				fragmentShader: document.getElementById( 'effect2Shader' ).textContent
			} );
			var texScene = new THREE.Scene();
			var texMesh = new THREE.Mesh( new THREE.PlaneBufferGeometry( 2, 2 ), passThruShader );
			texScene.add(texMesh);
			var lineScene = new THREE.Scene();
			var lineMat = new THREE.LineBasicMaterial();
			var lineGeom = new THREE.Geometry();
			var lineObj = new THREE.Line( lineGeom, lineMat );
			lineScene.add(lineObj);

			currentShader = effectShader;
			outShader = passThruShader;

			// Takes a texture, and render out as another texture
			var renderTexture = function ( input, output ) {
				texMesh.material = passThruShader;
				passThruShader.uniforms.texture.value = input;
				renderer.render( texScene, texCam, output );
			}
			//applies shader to input, writing to output and screen
			var renderTick = function(input, shader, output) {
				texMesh.material = shader;
				shader.uniforms.old.value = input;
				shader.uniforms.interact.value.set(mouseX,mouseY,mouseZ,mouseValue);
				shader.uniforms.icolor.value.set(mouseRed,mouseGreen,mouseBlue)
				renderer.render( texScene, texCam, output );
			}
			//doesn't work yet
			var addLine = function(x1,y1,x2,y2,c){
				lineGeom.vertices = [
					new THREE.Vector3(x1,y1,0.0),
					new THREE.Vector3(x2,y2,0.0),
					];
				lineGeom.verticesNeedUpdate = true;
				lineMat.color = c;

				var tex = flipflop ? canvTex0 : canvTex1;
				renderer.render( lineScene, texCam, tex);
			}
			var renderFinal = function(){
				var tex = flipflop ? canvTex0 : canvTex1;
				texMesh.material = outShader;
				passThruShader.uniforms.texture.value = tex;
				renderer.render( texScene, texCam);
			}
			var flipflop = false;
			var flip = function() {
				if (flipflop) {
					renderTick( canvTex1, currentShader, canvTex0 );
				} else {
					renderTick( canvTex0, currentShader, canvTex1 );
				}
				flipflop = !flipflop;
			}

			//initialize data
			var a = new Float32Array( WIDTH * WIDTH * 4 );

			var texture = new THREE.DataTexture( a, WIDTH, WIDTH, THREE.RGBAFormat, THREE.FloatType );
			texture.minFilter = THREE.NearestFilter;
			texture.magFilter = THREE.NearestFilter;
			texture.needsUpdate = true;
			texture.flipY = false;
			renderTexture(texture, canvTex0);


			//window.addEventListener( 'resize', onWindowResize, false );
			document.addEventListener("keydown", onKeyDown, false);
			document.addEventListener("keyup",   onKeyUp,   false);
			document.addEventListener( 'mousemove', onMouseM, false );
			document.addEventListener( 'mousedown', onMouseD, false );
			document.addEventListener( 'mouseup', onMouseU, false );
			
			//inital status
			mouseOldX = 0;
			mouseOldY = 0;
			mouseOldZ = 0;
			mouseX = 0;
			mouseY = 0;
			mouseZ = 0;
			mouseValue = 0.0;
			mouseRed = 1.0;
			mouseGreen = 1.0;
			mouseBlue = 1.0;

			shaders = [effectShader, effect2Shader];
			shaderIndex = 0;

			windowHalfX = window.innerWidth / 2;
			windowHalfY = window.innerHeight / 2;

			function onMouseM( event ) {
				mouseOldX = mouseX;
				mouseOldY = mouseY;
				mouseX = event.clientX;
				mouseY = WIDTH - event.clientY;

				if(mouseValue > 0.0){
					addLine(mouseOldX,mouseOldY,mouseX,mouseY,
						new THREE.Color(mouseRed,mouseGreen,mouseBlue));
				}
			}
			function onMouseD( event ) {
				mouseValue = 1.0;

				mouseRed = Math.random();
				mouseGreen = Math.random();
				mouseBlue = Math.random();
				while(mouseRed+mouseGreen+mouseBlue < 0.6){
					mouseRed = Math.random();
					mouseGreen = Math.random();
					mouseBlue = Math.random();
				}
			}
			function onMouseU( event ) {
				mouseValue = 0.0;
			}
			repeat = true;
			function onKeyDown(){
				repeat = !repeat;
				if(repeat){
					shaderIndex = (shaderIndex + 1) % shaders.length;
					currentShader = outShader = shaders[shaderIndex];
				}else{
					outShader = saShader;
					renderFinal();
				}
			}
			function onKeyUp(){
				//repeat = true;
			}

			var framecount = 0;
			var oldtime = new Date().getTime();

			var render = function () {
				requestAnimationFrame( render );
				if(repeat) {
					flip();
					//fast
					flip();flip();flip();
					//flip();flip();flip();flip();

					renderFinal();

					//console frames per second
					framecount++;
					var newtime = new Date().getTime();
					if(newtime-oldtime>1000){
						oldtime = newtime;
						console.log(framecount);
						framecount = 0;
					}

				}
			};
			render();



		</script>
	</body>
</html>